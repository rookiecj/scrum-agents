You are the Scrum Master starting a planned sprint. Activate the sprint, enqueue tickets to the DEV queue, and dispatch agents.

## Input
Sprint start arguments: $ARGUMENTS

## Instructions

### 1. Identify the Sprint

- If sprint name/number is given in arguments, use it
- Otherwise, find the planned (next) sprint:
  ```bash
  gh issue list -R rookiecj/scrum-agents -l "sprint:next" --state open
  ```
- If no `sprint:next` tickets exist, inform the user they need to run `/sprint plan` first

### 2. Activate the Sprint & Enqueue to DEV Queue

First, validate that no `sprint:next` tickets have pre-existing `status:*` labels (they should not have been assigned during planning):
```bash
# Check for incorrectly labeled tickets
gh issue list -R rookiecj/scrum-agents -l "sprint:next" --state open --json number,labels | \
  jq '[.[] | select(.labels[].name | startswith("status:"))]'
```
If any tickets have `status:*` labels, remove them before proceeding.

Move all `sprint:next` tickets to `sprint:current` and enqueue them as `status:planned`:
```bash
# For each sprint ticket
gh issue edit <number> -R rookiecj/scrum-agents \
  --remove-label "sprint:next" \
  --add-label "sprint:current,status:planned"
```

### 3. Create PROGRESS.md

Read `PLAN.md` from the project root to get the sprint goal and ticket list. Then create `PROGRESS.md` in the project root to track sprint execution.

Use the Write tool to create `PROGRESS.md` with the following structure:

```markdown
# Sprint Progress

> Auto-generated by sprint:start. Updated by agents during the sprint.

## Sprint Goal

<copy from PLAN.md>

## Board

### DEV Queue (status:planned)

- #N [Type] Title (Xpts, Component)

### In Progress (status:in-progress)

(none)

### QA Queue (status:dev-complete)

(none)

### In Review (status:in-review)

(none)

### Verified (status:verified)

(none)

### Blocked (status:blocked)

(none)

## Ticket Log

| # | Title | Agent | Status | Branch | Notes |
|---|-------|-------|--------|--------|-------|

## Handoff Notes

<cross-agent context that needs to be shared: API contracts, schema changes, shared types, etc.>
```

**Guidelines:**

- Board section: populate DEV Queue from the activated tickets
- Ticket Log: will be appended by agents as they claim/complete tickets
- Handoff Notes: agents write here when their work produces context needed by other agents (e.g., backend-dev documents a new API endpoint that frontend-dev needs to consume)

### 4. Display Sprint Board

Show the PROGRESS.md board section to the user as confirmation.

### 5. Dispatch Agents

Detect dispatch mode from arguments, or ask the user:

- If arguments contain `parallel` or `para` ‚Üí use **Parallel Mode** automatically (skip asking)
- If arguments contain `sequential` or `seq` ‚Üí use **Sequential Mode** automatically (skip asking)
- Otherwise ‚Üí ask the user which mode to use

#### Sequential Mode (single agent)
Process tickets one by one, acting as Dev, QA, and Scrum Master:

For each ticket in the DEV queue (priority order: critical ‚Üí high ‚Üí medium ‚Üí low):

**DEV Phase:**
1. Claim: `status:planned` ‚Üí `status:in-progress`
2. Read the full ticket: `gh issue view <number> -R rookiecj/scrum-agents`
3. Implement based on component label (see component-specific instructions below)
4. Create a PR for the feature branch:
   ```bash
   git push -u origin feature/<number>-<short-description>
   gh pr create -R rookiecj/scrum-agents \
     --title "feat: <description> (#<number>)" \
     --body "Closes #<number>" \
     --base main
   ```
5. Complete: `status:in-progress` ‚Üí `status:dev-complete`

**QA Phase:**
6. Claim: `status:dev-complete` ‚Üí `status:in-review`
7. Verify each acceptance criterion
8. If pass: `status:in-review` ‚Üí `status:verified` (do NOT close the issue)
9. If fail:
   - Post verification results as a comment on the ticket:
     ```bash
     gh issue comment <number> -R rookiecj/scrum-agents \
       --body "‚ùå **QA Failed**: Returning to DEV queue for rework.

     **Verification Results:**
     | AC | Result | Detail |
     |----|--------|--------|
     | <acceptance criterion 1> | PASS/FAIL | <detail> |
     | <acceptance criterion 2> | PASS/FAIL | <detail> |

     **Failure Summary**: <what specifically failed and why>
     **Suggested Fix**: <actionable guidance for the developer>"
     ```
   - Transition: `status:in-review` ‚Üí `status:planned`
     ```bash
     gh issue edit <number> -R rookiecj/scrum-agents \
       --remove-label "status:in-review" \
       --add-label "status:planned"
     ```
   - The ticket returns to the DEV queue and should be prioritized for rework in the next cycle

**Merge Phase (Scrum Master, after QA pass):**
10. For each `status:verified` ticket, the Scrum Master merges the PR:
    ```bash
    # Find the PR for this ticket's branch
    gh pr list -R rookiecj/scrum-agents --head feature/<number>-<short-description> --json number,url

    # Merge the PR (squash merge to keep main history clean)
    gh pr merge <pr-number> -R rookiecj/scrum-agents --squash --delete-branch
    ```
    The PR body's `Closes #<number>` will automatically close the issue on merge.
    If auto-close does not trigger, close manually:
    ```bash
    gh issue close <number> -R rookiecj/scrum-agents \
      --comment "‚úÖ PR merged to main."
    ```

**Component-specific implementation:**

For `component:backend` tickets:
- Fetch latest main and create feature branch:
  ```bash
  git fetch origin main
  git checkout -b feature/<number>-<short-description> origin/main
  ```
- Implement in `backend/` following Go conventions from CLAUDE.md
- Write tests (table-driven tests)
- Run `cd backend && go build ./... && go test ./... -v`
- Commit with conventional commit: `feat: <description> (#<number>)`
- Push and create PR:
  ```bash
  git push -u origin feature/<number>-<short-description>
  gh pr create -R rookiecj/scrum-agents \
    --title "feat: <description> (#<number>)" \
    --body "Closes #<number>"
  ```

For `component:frontend` tickets:
- Fetch latest main and create feature branch:
  ```bash
  git fetch origin main
  git checkout -b feature/<number>-<short-description> origin/main
  ```
- Implement in `frontend/` following TypeScript conventions from CLAUDE.md
- Write tests
- Run `cd frontend && npm run build && npm test`
- Commit with conventional commit: `feat: <description> (#<number>)`
- Push and create PR:
  ```bash
  git push -u origin feature/<number>-<short-description>
  gh pr create -R rookiecj/scrum-agents \
    --title "feat: <description> (#<number>)" \
    --body "Closes #<number>"
  ```

For tickets with both components:
- Implement backend first, then frontend
- Same branch for both

#### Parallel Mode (multi-agent team)

Use the Task tool to spawn agents in two phases. Each agent runs in an **isolated git worktree** (`isolation: "worktree"`) to avoid working directory conflicts.

**Pre-flight: Handle dual-component tickets**
Before dispatching, check for tickets with both `component:backend` and `component:frontend`. These must be assigned to one agent explicitly (default: backend-dev handles the full ticket). Remove the other component label temporarily, or split the ticket.

**Phase 1 ‚Äî Dev Agents (parallel)**
Read the agent definition files and include their full content in the Task tool prompt. Spawn Backend Dev and Frontend Dev simultaneously:

```
Task tool call #1:
  description: "Backend dev sprint work"
  subagent_type: "general-purpose"
  isolation: "worktree"
  prompt: |
    <paste full contents of .claude/agents/backend-dev.md>

    ## Sprint Context
    First, read `PLAN.md` and `PROGRESS.md` from the project root to understand
    the sprint goal, ticket details, and current progress.

    You are working on sprint tickets. Process ALL `component:backend` + `status:planned`
    tickets in priority order (critical ‚Üí high ‚Üí medium ‚Üí low).
    For each ticket:
    1. Claim: `status:planned` ‚Üí `status:in-progress`
    2. Fetch latest main and create feature branch:
       `git fetch origin main && git checkout -b feature/<number>-<short-description> origin/main`
    3. Implement, write tests, commit
    4. Push branch and create a PR (`gh pr create` with `Closes #<number>` in body)
    5. Mark `status:dev-complete`
    After completing each ticket, update `PROGRESS.md`:
    - Move the ticket in the Board section to reflect its new status
    - Add a row to the Ticket Log table
    - If your work produces context needed by other agents (API endpoints, schema changes,
      shared types), write it in the Handoff Notes section
    Stop when the DEV queue for backend is empty.

Task tool call #2:
  description: "Frontend dev sprint work"
  subagent_type: "general-purpose"
  isolation: "worktree"
  prompt: |
    <paste full contents of .claude/agents/frontend-dev.md>

    ## Sprint Context
    First, read `PLAN.md` and `PROGRESS.md` from the project root to understand
    the sprint goal, ticket details, and current progress.

    You are working on sprint tickets. Process ALL `component:frontend` + `status:planned`
    tickets in priority order (critical ‚Üí high ‚Üí medium ‚Üí low).
    For each ticket:
    1. Claim: `status:planned` ‚Üí `status:in-progress`
    2. Fetch latest main and create feature branch:
       `git fetch origin main && git checkout -b feature/<number>-<short-description> origin/main`
    3. Implement, write tests, commit
    4. Push branch and create a PR (`gh pr create` with `Closes #<number>` in body)
    5. Mark `status:dev-complete`
    After completing each ticket, update `PROGRESS.md`:
    - Move the ticket in the Board section to reflect its new status
    - Add a row to the Ticket Log table
    - If your work produces context needed by other agents (component interfaces,
      API consumption details), write it in the Handoff Notes section
    Check the Handoff Notes section for context from other agents before starting work.
    Stop when the DEV queue for frontend is empty.
```

**Phase 2 ‚Äî QA Agent (after dev agents complete or when QA queue has items)**
Wait for at least one Dev Agent to complete, or check that `status:dev-complete` tickets exist, then spawn QA:

```
Task tool call #3:
  description: "QA verification sprint work"
  subagent_type: "general-purpose"
  isolation: "worktree"
  prompt: |
    <paste full contents of .claude/agents/qa.md>

    ## Sprint Context
    First, read `PLAN.md` and `PROGRESS.md` from the project root to understand
    the sprint goal, ticket details, and current progress. Check the Handoff Notes
    section for context from dev agents (API contracts, schema changes, etc.)
    that may be relevant to verification.

    You are verifying sprint tickets. Process ALL `status:dev-complete` tickets.
    For each ticket: claim ‚Üí verify AC ‚Üí pass or fail.

    **If verification fails:**
    - Post a detailed comment on the ticket with:
      - AC-by-AC verification results table (PASS/FAIL per criterion)
      - Failure summary explaining what specifically failed
      - Suggested fix with actionable guidance for the developer
    - Transition: `status:in-review` ‚Üí `status:planned` (return to DEV queue)

    **If verification passes:**
    - Transition: `status:in-review` ‚Üí `status:verified` (do NOT close the issue)

    After verifying each ticket, update `PROGRESS.md`:
    - Move the ticket in the Board section to reflect its new status
    - Add a row to the Ticket Log table with verification result
    Stop when the QA queue is empty AND no tickets are in `status:in-progress`
    (meaning no more dev work will produce new QA items).
```

**Phase 3 ‚Äî Scrum Master merges verified PRs**
After QA Agent completes, the Scrum Master merges all `status:verified` tickets' PRs:

```bash
# Find all verified tickets
gh issue list -R rookiecj/scrum-agents -l "sprint:current" -l "status:verified" --state open --json number
```

For each `status:verified` ticket:
1. Find and merge the PR:
   ```bash
   gh pr list -R rookiecj/scrum-agents --head feature/<number>-<short-description> --json number,url
   gh pr merge <pr-number> -R rookiecj/scrum-agents --squash --delete-branch
   ```
2. The PR body's `Closes #<number>` will automatically close the issue on merge.
   If auto-close does not trigger, close manually:
   ```bash
   gh issue close <number> -R rookiecj/scrum-agents \
     --comment "‚úÖ PR merged to main."
   ```

**Error handling:**
- If a Dev Agent task fails mid-execution, its claimed tickets (`status:in-progress`) will be stale. The Scrum Master should detect these via Queue Health Check and transition them back to `status:planned`.
- If the QA Agent task fails, `status:in-review` tickets should be transitioned back to `status:dev-complete` by the Scrum Master.
- After all agents complete, run a final Queue Health Check to detect any orphaned tickets.

### 6. Handle Blockers

If a ticket is blocked during implementation:
```bash
# Mark as blocked (remove current status first)
gh issue edit <number> -R rookiecj/scrum-agents \
  --remove-label "status:planned" \
  --add-label "status:blocked"
gh issue comment <number> -R rookiecj/scrum-agents \
  --body "üö´ **Blocked**: <reason for block>. Previous state: status:planned."
```
- Skip to the next unblocked ticket

When the blocker is resolved, unblock the ticket:
```bash
gh issue edit <number> -R rookiecj/scrum-agents \
  --remove-label "status:blocked" \
  --add-label "status:planned"
gh issue comment <number> -R rookiecj/scrum-agents \
  --body "üîì **Unblocked**: Blocker resolved. Returning to DEV queue."
```

### 7. Sprint Progress Updates

After each ticket completion, show queue-based progress:
```
## Sprint Progress
- DEV Queue:    X tickets
- In Progress:  X tickets
- QA Queue:     X tickets
- In Review:    X tickets
- Verified:     X/Y tickets (XX%)
- Blocked:      X tickets
- Points Done:  XX/XX pts
```

## Important
- **Status labels are mutually exclusive**: always remove the previous status label before adding the new one
- Always create feature branches ‚Äî never commit directly to main
- Run tests before marking tickets as dev-complete
- If implementation requires design decisions not in the ticket, ask the user
- Commit messages must follow conventional commit format and reference the issue number
- If a ticket turns out to be larger than estimated, inform the user and discuss splitting
- QA rework tickets (returned to `status:planned` with failure comments) should be prioritized
